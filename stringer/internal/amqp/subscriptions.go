// Code generated by Godin v0.5.0; DO NOT EDIT.
package amqp

import (
	"github.com/pkg/errors"

	"github.com/go-godin/log"
	middleware "github.com/go-godin/middleware/amqp"
	"github.com/go-godin/rabbitmq"

	"github.com/lukasjarosch/godin-examples/stringer/internal/service"
	"github.com/lukasjarosch/godin-examples/stringer/internal/service/subscriber"
)

type SubscriberSet struct {
	userCreated rabbitmq.Subscriber
	userDeleted rabbitmq.Subscriber
}

// Subscriptions will initialize all AMQP subscriptions. For each subscription, a new AMQP channel is created on which
// the Consume() goroutine will run (one channel per thread policy).
func Subscriptions(conn *rabbitmq.RabbitMQ) SubscriberSet {
	userCreatedChannel, _ := conn.NewChannel()
	userDeletedChannel, _ := conn.NewChannel()

	return SubscriberSet{
		userCreated: rabbitmq.NewSubscriber(userCreatedChannel, &rabbitmq.Subscription{
			Exchange:      "exchange-name",
			Topic:         "user.created",
			AutoAck:       false,
			PrefetchCount: 10,
			Queue: rabbitmq.SubscriptionQueue{
				AutoDelete: false,
				Durable:    true,
				Exclusive:  false,
				Name:       "user-created-queue",
				NoWait:     false,
			},
		}),

		userDeleted: rabbitmq.NewSubscriber(userDeletedChannel, &rabbitmq.Subscription{
			Exchange:      "exchange-name",
			Topic:         "user.deleted",
			AutoAck:       false,
			PrefetchCount: 10,
			Queue: rabbitmq.SubscriptionQueue{
				AutoDelete: false,
				Durable:    true,
				Exclusive:  false,
				Name:       "user-deleted-queue",
				NoWait:     false,
			},
		}),
	}
}

// UserCreated sets up the subscription to the 'user.created' topic. All middleware is automatically registered
// and called in the following order: RequestID => PrometheusInstrumentation => Logging => subscriber.UserCreated
// The RequestID middlware will extract the requestId from the delivery header or generate a new one. The requestId is
// then mad available through the context.
func (ss SubscriberSet) UserCreated(logger log.Logger, usecase service.Stringer) error {
	handler := subscriber.UserCreatedSubscriber(logger, usecase, UserCreatedDecoder)
	handler = middleware.Logging(logger, "user.created", handler)
	handler = middleware.PrometheusInstrumentation("user.created", handler)
	handler = middleware.RequestID(handler)

	if err := ss.userCreated.Subscribe(handler); err != nil {
		logger.Error("failed to subscribe to user.created", "err", err, "transport", "AMQP")
		return errors.Wrap(err, "failed to subscribe to user.created")
	}
	logger.Info(
		"subscribed to topic 'user.created'",
		"topic", ss.userCreated.Subscription.Topic,
		"queue", ss.userCreated.Subscription.Queue.Name,
		"exchange", ss.userCreated.Subscription.Exchange,
		"prefetch_count", ss.userCreated.Subscription.PrefetchCount,
		"transport", "AMQP",
	)

	return nil
}

// UserDeleted sets up the subscription to the 'user.deleted' topic. All middleware is automatically registered
// and called in the following order: RequestID => PrometheusInstrumentation => Logging => subscriber.UserDeleted
// The RequestID middlware will extract the requestId from the delivery header or generate a new one. The requestId is
// then mad available through the context.
func (ss SubscriberSet) UserDeleted(logger log.Logger, usecase service.Stringer) error {
	handler := subscriber.UserDeletedSubscriber(logger, usecase, UserDeletedDecoder)
	handler = middleware.Logging(logger, "user.deleted", handler)
	handler = middleware.PrometheusInstrumentation("user.deleted", handler)
	handler = middleware.RequestID(handler)

	if err := ss.userDeleted.Subscribe(handler); err != nil {
		logger.Error("failed to subscribe to user.deleted", "err", err, "transport", "AMQP")
		return errors.Wrap(err, "failed to subscribe to user.deleted")
	}
	logger.Info(
		"subscribed to topic 'user.deleted'",
		"topic", ss.userDeleted.Subscription.Topic,
		"queue", ss.userDeleted.Subscription.Queue.Name,
		"exchange", ss.userDeleted.Subscription.Exchange,
		"prefetch_count", ss.userDeleted.Subscription.PrefetchCount,
		"transport", "AMQP",
	)

	return nil
}

// Shutdown will call Shutdown() on all registered subscriptions
func (ss SubscriberSet) Shutdown() (err error) {
	err = ss.userCreated.Shutdown()
	err = ss.userDeleted.Shutdown()

	return err
}
